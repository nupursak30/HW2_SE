


__Creational Design Pattern:__ [[1](https://sourcemaking.com/design_patterns)]
1. _Abstract Factory Design Pattern:_
   This design pattern provides an interface to create families of dependent objects without having the need to specify the concrete classes to which they belong to. So, it can be considered as a hierarchy pattern which consists of multiple platforms and a collection of multiple products
This design pattern consists of a 'factory object' which provides creation services to the entire platform of family. So this means that a client never has to create platform objects on their own, it can ask the factory object to do it for them.
The advantage of this pattern is that it helps to make easy exchanges between product families. This is because the specific class of factory object is instantiated only once and hence it appears only one time in the whole application. Morever, the application has the ability to instantiate a different concrete instance of abstract factory, thereby giving it the power to replace the entire family of products. It is usually implemented as a Singleton due to the pervasive nature of the services provided by the factory object.
The structure of the factory product is defined by a Factory Method assigned for each product. The new operator and the concrete, platform-specific, product classes are encapsulated within this Factory Method. 
EXAMPLE: The sheet metal stamping equipment used in the manufacturing of Japanese automobiles is based on this pattern. The same metal stamping equipment is used to stamp all types of doors, fenders, wheels, etc.for different models of cars. So, this equipment can be considered as an Abstract Factory object which provides stamping services to the entire platform of families(hoods, doors,etc.)


2. _Prototype Design Pattern:_
This design pattern basically uses a prototypical instance to specify the different kinds of objects it wants to create and then creates new objects by copying this prototypical instance. So using this pattern, one instance of the class can be used as a breeder for all the future instances as this pattern basically copies the prototype instance. 
This design pattern basically consists of an abstract base class which specifies a virtual pure clone Method and then keeps a track of all cloneable concrete classes derived from it using a dictionary. Thus, if any class wants to have the capability of a 'polymorphic constructor', it simply needs to derive it from this abstract base class, register its prototypical instance and then finally do the cloning operation. So now the client can directly call the clone operation on the abstract base class. 
The structure of this design pattern consists of a Factory which can find the correct Prototype to clone with and then each product knows how to spawn new instances of itself. 
EXAMPLE: The single cell division resulting into two identical cells formation is an example of Prototype design pattern as in this case, two identical cells are formed i.e. the cell clones itself by using its own prototype. 


__Structural Design Patterns:__[[1](https://sourcemaking.com/design_patterns)]
1. _Bridge Design Pattern:_ This design pattern is used to separate the abstraction from the implementation, thereby allowing them to vary independently of each other. The Bridge Design Pattern allows to refactor the inheritance hierarchy into two separate orthogonal hierarchies, such that one belongs to plaform independent abstractions and the other one belongs to platform dependent implementations. 
This design pattern divides the component's interface and implementation into orthogonal class hierarchies. A pointer is present in the interface class which points to the implementation class. Even though initialization of this pointer is done using an instance of the concrete implementation class, all the future interactions of the interface class with the implementation class is limited to abstraction maintained in the implementation base class. So, the client now interacts with the interface class and the interface class forwards all the client requests to the implementation class. The interface object is called as 'handle' which is used by the client to interact with the interface class whereas the implementation object which is called as 'body' is not accessible by the client and is safely encapsulated. 
EXAMPLE: A switch which controls the lightings of a house/apartment can be considered to be based on a Bridge Design Pattern. The client(user who wants to use the switch to control the lightings) just interacts with the interface class which simply has a job of turning on or off a switch. However, the actual implementation of the switch is complex and is thus, hidden from the user and the user cannot access it. 


2. _Proxy Design Pattern:_ This design pattern provides a surrogate or a proxy object for another object so that it can control access to it.This design pattern is like caching. The actual object is instantiated when the client first time calls for the proxy object. Then, the proxy object remembers the actual real object identity and thus forwards the instantiation requests to this actual object. After this, all the subsequent future requests made by the client are simply forwarded directly to the encapsulated actual object. The presence of the proxy object is being made transparent to the client by using a 'subject' interface , thereby making the client to interact with the proxy object instead of the actual real object.
EXAMPLE: An e-check or money order draft can be considered as proxy objects for the actual object 'monetary funds' of the bank account as they can be used by the clients to make purchases, pay deposits, etc. thereby allowing these proxy objects to control access to the actual object 'monetary funds' present in the bank account.


__Behavioral Design Patterns:__[[1](https://sourcemaking.com/design_patterns)]
1. _Observer Design Pattern:_ This design pattern defines one-to-many dependency between objects and thus, whenever an object changes its state, all the other dependent objects are notified and updated automatically. It consists of two things - Subject Abstraction and Observer Hierarchy. All the core elements are kept in the Subject Abstraction whereas all the variable components are kept in the Observer Hierarchy. 
Observer Design Pattern consists of a Subject object which keeps track of all the data model and/or the business logic associated with it. It also delegates all the 'view' functionality to separate and distinct Observer Objects. These Observer objects are registered automatically with the Subject as they get created. This allows the Subject to broadcasts the changes to all its registered Observers whenever its state is changed. Every Observer then queries on an individual basis to the Subject and thus, gets updated with the respective changes.
The structure of this design pattern consists of a subject which forms the core(independent) abstraction. Observer represents the variable(dependent) abstraction.
EXAMPLE: Auctions can be considered to be an Observer Design Pattern. The Auctioneer can be considered to be the Subject and all the bidders can be considered as the Observer Objects which observes the bid broadcasted by the Auctioneer and updates their bids accordingly. 


2. _Command Design Pattern:_ This design pattern encapsulates the requests/commands coming from clients as an object, thereby allowing the clients to parametrize with different requests. In this design pattern, Command helps to decouple the object which invokes the operation from the one which actually performs the whole operation. In order to achieve this, an abstract base class is created and this class helps to map a receiver which is an object with an action which is basically a pointer to the member function by calling an 'execute' method present in it. Command objects are like tokens - which are created by one client but are passed to the other client which will use them as they have the resources needed to use it.  
EXAMPLE: The notepad carried by the waiters/waitress in restaurants can be considered as a Command Design Pattern. The customer gives order(commands) to the waiter and the waiter encapsulates this order by writing it down in the notepad(object). This notepad is not limited to a specific food item, it can support many variety of food items in it.

__Free Style Patterns__  
1._Repository Pattern:_[[2](https://msdn.microsoft.com/en-us/library/ee413961.aspx)] This pattern basically uses a repository that separates the logic which is used to retrieve the data from the business logic that actually acts on the model i.e. the business logic should have no idea about the data type(Webservice, database, etc.) present in the data source layer. The repository is present betweent the business and the data source layers of the application. It retrieves data from the data source layer, maps it to a business entity and then it also notifies the data source about any changes done to the data by the business entity.The advantages of this pattern is that it helps to provide substitution points for the unit tests. It also provides a flexible architecture which can be changed as the application evolves in the future. 

2._Service Locator Pattern:_[[3](https://msdn.microsoft.com/en-us/library/ee413842.aspx)] In this design pattern, a service locator is created which has references to the client requested services and it also encapsulates the logic that locates them. Inside the classes, the service locater can be used to obtain service instances. This locator doesn't tell about how to go ahead with the instantiation of the services. Instead, it talks about how to register and locate services. Generally, the Service locator is combined with Factory Pattern which allows the locator to create instances of services.
Service Locator Pattern can be used to test classes in isolation, without any dependencies required for them. 

3._Model-View-Presenter (MVP) Pattern:_[[4](https://msdn.microsoft.com/en-us/library/ff649571.aspx)] This pattern separates the logic for the visual display from that of the event handling behavior by assigning them to two different classes - the view and the presenter. The view class(Web part) controls the Web Page and also sends the client events to a presenter. The presenter knows the logic needed to repond to these events and so it updates the model(business logic and data application) accordingly. After this, it changes the state of the view. In order to make the presenter testable by the client, a view interface needs to be defined. Now the presenter will use the view interface instead of the actual view implementation class. This helps to decouple the presenter from the view implementation class, thereby making it easy to implement unit tests for this pattern.  





